<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Uptest substrate documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="my-first-chapter.html"><strong aria-hidden="true">1.</strong> Libuptest introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="code/jsonrpc.html"><strong aria-hidden="true">1.1.</strong> Libuptest connect to a chain with JsonRPCClient</a></li><li class="chapter-item expanded "><a href="code/types.html"><strong aria-hidden="true">1.2.</strong> Libuptest types</a></li><li class="chapter-item expanded "><a href="code/ws_mod.html"><strong aria-hidden="true">1.3.</strong> Libuptest ws_mod helper</a></li><li class="chapter-item expanded "><a href="code/decode.html"><strong aria-hidden="true">1.4.</strong> Libuptest Decoding Extrinsics</a></li></ol></li><li class="chapter-item expanded "><a href="cli/index.html"><strong aria-hidden="true">2.</strong> Uptest command line tool</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cli/watch_runtime_upgrade.html"><strong aria-hidden="true">2.1.</strong> Watch for runtime upgrades and custom events</a></li><li class="chapter-item expanded "><a href="cli/event_sub.html"><strong aria-hidden="true">2.2.</strong> Subscribe to block events</a></li></ol></li><li class="chapter-item expanded "><a href="code_samples/index.html"><strong aria-hidden="true">3.</strong> Libuptest code examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="code_samples/upgrade_change_diff.html"><strong aria-hidden="true">3.1.</strong> Check added and changed storage items after a runtime upgrade</a></li><li class="chapter-item expanded "><a href="code_samples/subxt.html"><strong aria-hidden="true">3.2.</strong> Using Libuptest with Subxt</a></li><li class="chapter-item expanded "><a href="code_samples/random.html"><strong aria-hidden="true">3.3.</strong> Libuptest random input generation</a></li></ol></li><li class="chapter-item expanded "><a href="action/index.html"><strong aria-hidden="true">4.</strong> Libuptest in Action</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="action/tutorial_1.html"><strong aria-hidden="true">4.1.</strong> Tutorial #1 preventing breaking upgrades</a></li><li class="chapter-item expanded "><a href="action/submit.html"><strong aria-hidden="true">4.2.</strong> Submitting runtime upgrades</a></li></ol></li><li class="chapter-item expanded "><a href="case_study/index.html"><strong aria-hidden="true">5.</strong> Real chains breaking - Case studies</a></li><li class="chapter-item expanded "><a href="action/auto-test.html"><strong aria-hidden="true">6.</strong> Automatically generate tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cli/auto-test.html"><strong aria-hidden="true">6.1.</strong> uptest-cli auto-test</a></li><li class="chapter-item expanded "><a href="code/autotest.html"><strong aria-hidden="true">6.2.</strong> libuptest auto-test</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Uptest substrate documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/uptest-sc/uptest-sc.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Uptest(cli client) and Libuptest(core library) was created in order to make debugging of substrate based Runtime Upgrades easier.</p>
<p>Uptest contains several useful features and modules that helps developers detect changes that took place before and after the runtime upgrade was pushed.</p>
<h3 id="useful-links"><a class="header" href="#useful-links">Useful links:</a></h3>
<p><a href="https://github.com/uptest-sc/uptest">Uptest github</a><br />
<a href="https://github.com/apopiak/substrate-migrations">https://github.com/apopiak/substrate-migrations</a><br />
<a href="https://github.com/paritytech/substrate/issues?q=label%3AE1-runtimemigration%20">Runtime migration issues for substrate</a><br />
<a href="https://docs.rs/libuptest/0.1.1/libuptest/">doc.rs for Libuptest</a></p>
<h3 id="contribute"><a class="header" href="#contribute">Contribute:</a></h3>
<p>If you want to modify or contribute to this documentation, you can do so by submitting a pull request to:<br />
<a href="https://github.com/uptest-sc/uptest-sc.github.io">https://github.com/uptest-sc/uptest-sc.github.io</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-and-utilize-uptest"><a class="header" href="#install-and-utilize-uptest">Install and utilize Uptest:</a></h1>
<h2 id="libuptest-can-be-found-at-cratesio-and-github"><a class="header" href="#libuptest-can-be-found-at-cratesio-and-github">Libuptest can be found at crates.io and github:</a></h2>
<pre><code class="language-shell">$ cargo new --bin try_uptest  
$ cd try_uptest/
$ cat rust-toolchain
[toolchain]
channel = &quot;nightly-2023-04-24&quot;
targets = [&quot;wasm32-unknown-unknown&quot;]
profile = &quot;default&quot;
host = &quot;x86_64-unknown-linux-gnu&quot;
$ cat Cargo.toml  
[package]
name = &quot;uptest-cli&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
libuptest = &quot;0.1.1&quot;
</code></pre>
<p>Note: Libuptest is currently only avaliable in the nightly edition, so you need to configure your rust-toolchain for that.</p>
<h2 id="libuptest-feature-flags"><a class="header" href="#libuptest-feature-flags">Libuptest feature flags</a></h2>
<p>We wanted to make uptest a minimal and stand-alone library so Libuptest comes with multiple feature flags that you can enable:</p>
<h4 id="metadatadecode"><a class="header" href="#metadatadecode">metadatadecode</a></h4>
<p>This feature flag is used for adding extrinsic decoding functionality to uptest. By enabling this flag you unlock the following functions:
unctions with metadatadecode flag:<br />
https://github.com/search?q=repo%3Auptest-sc%2Fuptest%20%23%5Bcfg(feature%20%3D%20%22metadatadecode%22)%5D&amp;type=code&quot;</p>
<h4 id="subxt"><a class="header" href="#subxt">Subxt:</a></h4>
<p>Feature flag not yet published.</p>
<h4 id="all"><a class="header" href="#all">ALL</a></h4>
<p>The &quot;ALL&quot; feature flag does exactly what the name entails. It enables all avaliable feature flags.</p>
<p><a href="https://docs.rs/crate/libuptest/0.1.1/features">All current feature flags on doc.rs</a></p>
<h4 id="limitations-of-uptest"><a class="header" href="#limitations-of-uptest">Limitations of uptest:</a></h4>
<ul>
<li>Currently only supports metadata version 14 format</li>
<li>Is running nightly rust and contains several unwrap's</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libuptest-jsonrpcclient"><a class="header" href="#libuptest-jsonrpcclient">Libuptest JsonRPCClient</a></h1>
<p>Uptest use a modified version of <a href="https://github.com/paritytech/jsonrpsee/">Jsonrpsee</a> from parity to connect to a chain.<br />
This makes uptest compatible with standard JsonRpsee syntax.</p>
<h2 id="connect-to-chain"><a class="header" href="#connect-to-chain">Connect to chain:</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use libuptest::jsonrpseeclient::JsonrpseeClient;

let custom_client: JsonrpseeClient = JsonrpseeClient::new(&quot;ws://my_node.local:9944&quot;);   
<span class="boring">}</span></code></pre></pre>
<h2 id="default-endpoints-to-chains"><a class="header" href="#default-endpoints-to-chains">Default endpoints to chains</a></h2>
<p>Out of the box 5 pre-configured endpoints have been added: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// connect to ws://127.0.0.1:9944
let local_client: JsonrpseeClient = JsonrpseeClient::with_default_url();   

// connect to wss://edgeware.jelliedowl.net:443
let edgeware_client: JsonrpseeClient = JsonrpseeClient::edgeware_default_url();   

// connect to wss://polkadot-rpc-tn.dwellir.com:443
let polkadot_client: JsonrpseeClient = JsonrpseeClient::polkadot_default_url();   

// connect to wss://kusama-rpc-tn.dwellir.com:443
let kusama_client: JsonrpseeClient = JsonrpseeClient::kusama_default_url();   

// connect to wss://ws.mof.sora.org:443
let sora_client: JsonrpseeClient = JsonrpseeClient::sora_default_url();

<span class="boring">}</span></code></pre></pre>
<h2 id="subscribe-to-chain"><a class="header" href="#subscribe-to-chain">Subscribe to chain</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use libuptest::jsonrpseeclient::subscription::{HandleSubscription, Request};
use libuptest::jsonrpseeclient::subscription::Subscribe;


...

   /// create a subscription socket to chain_subscribeFinalizedHeads
   println!(&quot;Subscribing to latest finalized blocks&quot;);
    let mut subscrib: SubscriptionWrapper&lt;Header&gt; = client
        .clone()
        .subscribe::&lt;Header&gt;(
            &quot;chain_subscribeFinalizedHeads&quot;,
            RpcParams::new(),
            &quot;chain_unsubscribeFinalizedHeads&quot;,
        )?;

  for _ in 0..3 { // loop
        let tmp_client = JsonrpseeClient::polkadot_default_url().unwrap();
        let nextone = subscrib.next();// get the next Finalized block number
        let blocknr = nextone.unwrap().unwrap().number;
        println!(&quot;Latest finalized block: {:?}&quot;, blocknr);
        let blockhash: H256 = blocknumber_to_blockhash(tmp_client.clone(), blocknr.clone()) // convert blocknr to blockhash with libuptest
            .await?;
	}
// unsubscribe
   let _ = subscrib.unsubscribe();
    Ok(())

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libuptest-types"><a class="header" href="#libuptest-types">Libuptest types</a></h1>
<p>Libuptest comes prepackaged with several different types that will make debugging a bit easier.</p>
<p>Name:<br />
H256</p>
<p>Description:<br />
A H256 hash from <a href="https://crates.io/crates/fixed-hash">fixed-hash</a>, used as default blockhash.<br />
Manually set a block hash:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let blockhash: H256 = H256::from_str(&quot;0x89a5dde6705d345117f442dfacf02f4a59bf5cea3ab713a5c07fc4cd78be3a31&quot;).unwrap();//get_latest_finalized_head(client.clone()).await.unwrap();
<span class="boring">}</span></code></pre></pre>
<p>Used in code examples:<br />
<a href="https://github.com/uptest-sc/uptest/blob/main/examples/examples/detect_runtime_upgrade.rs">detect_runtime_upgrade</a><br />
<a href="https://github.com/uptest-sc/uptest/blob/main/examples/examples/get_block_events.rs">get_block_event</a></p>
<hr />
<p>Name: 
Header struct<br />
Description:
Block Header containing the block nr</p>
<p>Used in code examples:
Define a block header standard that subscribe to finalized heads returns:<br />
<a href="https://github.com/uptest-sc/uptest/blob/main/examples/examples/get_block_events.rs">get_block_events</a></p>
<hr />
<p>Name:<br />
event_summary struct</p>
<p>Description:<br />
event_summary is an easy high level way for developers to define a custom event.<br />
Create a generic event in the form of:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let myevent: event_summary = event_summary {
	pub pallet_name: &quot;Sudo&quot;.to_string(),
	pub pallet_method: &quot;secret_function&quot;.to_string(),
 }
<span class="boring">}</span></code></pre></pre>
<p>Used in code examples:<br />
<a href="https://github.com/uptest-sc/uptest/blob/main/examples/examples/decode_extrinsics.rs">decode_extrinsics</a><br />
<a href="https://github.com/uptest-sc/uptest/blob/main/examples/examples/get_block_events.rs">get_block_events</a><br />
<a href="https://github.com/uptest-sc/uptest/blob/main/examples/examples/schedule_check.rs">schedule_check</a><br />
<a href="https://github.com/uptest-sc/uptest/blob/main/examples/examples/upgrade_change_diff.rs">upgrade_change_diff</a></p>
<hr />
<p>Name:<br />
storage_types</p>
<p>Description:<br />
enum for defining what type of storage entry it is, is it a StorageValue, StorageMap or Unknown type?</p>
<p>Used in code examples:<br />
<a href="https://github.com/uptest-sc/uptest/blob/main/libuptest/src/pallet_storage_parse.rs">pallet_storage_parse module</a></p>
<hr />
<p>Name:
Block struct</p>
<p>Description:<br />
Generic substrate sp-runtime block containing header and extrinsics.</p>
<p>Used in code examples:</p>
<hr />
<p>Name:
PreBlock struct </p>
<p>Description:
A pre-block containing a block and justifications.</p>
<p>Used in code examples:<br />
<a href="https://github.com/uptest-sc/uptest/blob/main/examples/examples/block_events.rs">block_events</a><br />
<a href="https://github.com/uptest-sc/uptest/blob/main/examples/examples/detect_runtime_upgrade.rs">detect_runtime_upgrade</a></p>
<hr />
<p>Name:<br />
generic_block
Description:<br />
A generic block format containing a Header and a Vector of strings.</p>
<p>Used in code examples:</p>
<hr />
<p>Name:<br />
RuntimeVersionEvent</p>
<p>Description:<br />
Runtime Version Event struct containing a spec version number(u32).</p>
<p>Used in code examples:</p>
<hr />
<p>Name:
RuntimeEvent</p>
<p>Description:<br />
Runtime event, returning a RuntimeVersionEvent if it has a value, if not it returns an error</p>
<p>Used in code examples:</p>
<hr />
<p>Name:<br />
storage_map_info struct </p>
<p>Description: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub pallet_name: String,
    pub storage_item_name: String, // name of storagemap
    pub type_id: u32,              // take the type id and query the type_id to type function
    pub raw_type: desub_current::scale_info::TypeDef&lt;PortableForm&gt;,
    pub storage_type: storage_types,
<span class="boring">}</span></code></pre></pre>
<p>Used in code examples:<br />
<a href="https://github.com/uptest-sc/uptest/blob/main/examples/examples/upgrade_change_diff.rs">upgrade_change_diff</a><br />
<a href="https://github.com/uptest-sc/uptest/blob/main/examples/examples/get_pallet_storagemaps_storagevalues.rs">get_pallet_storagemaps_storagevalues</a></p>
<h3 id="external-links"><a class="header" href="#external-links">External links:</a></h3>
<p><a href="https://docs.rs/libuptest/0.1.1/libuptest/types/index.html">Libuptest docs.rs type documentation</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libuptest-ws_mod-helper"><a class="header" href="#libuptest-ws_mod-helper">Libuptest ws_mod helper</a></h1>
<p><code>use libuptest::ws_mod</code> is a collection of seperate functions that utilize the ws socket(Default port 9944) to talk directly to the chain and then render the results.</p>
<hr />
<p>Name of Function:<br />
event_watch<br />
Function description:<br />
The event_watch function subscribes to the latest finalized blocks, every time their is a new block(normally every 6 seconds), the function will look at the event's triggered in the block and match that against a user defined event. If it finds the event in a block it will return the H256 block hash of that block. Select how many blocks to wait for with the block_limit parameter.</p>
<p>inputs:</p>
<ul>
<li>client: JsonrpseeClient</li>
<li>event: event_summary</li>
<li>block_limit: u32</li>
</ul>
<p>outputs:</p>
<ul>
<li>Result&lt;H256, crate::error::Error&gt;</li>
</ul>
<p>Used in code example:
<a href="https://github.com/uptest-sc/uptest/blob/main/examples/examples/upgrade_change_diff.rs">upgrade_change_diff</a><br />
<a href="https://github.com/uptest-sc/uptest/blob/main/examples/examples/schedule_check.rs">schedule_check</a></p>
<p>Special feature flag needed:
Yes - feature = &quot;metadatadecode&quot;)</p>
<hr />
<p>Name of Function:
get_runtime_version</p>
<p>Function description:
Queries the <code>state.getRuntimeVersion</code> endpoint in order to get the runtime version information.</p>
<p>inputs:
client: JsonrpseeClient,
outputs:
RuntimeVersion Struct</p>
<p>Used in code example:<br />
<a href="https://github.com/uptest-sc/uptest/blob/main/examples/examples/upgrade_change_diff.rs">upgrade_change_diff</a><br />
<a href="https://github.com/uptest-sc/uptest/blob/main/examples/examples/detect_runtime_upgrade.rs">detect_runtime_upgrade</a></p>
<p>Special feature flag needed:
No</p>
<hr />
<p>Name of Function:
get_decoded_extrinsics_from_blockhash</p>
<p>Function description:
Takes in a blockhash as input and decodes the extriniscs into the nice human readable format with event_summary struct.</p>
<p>inputs:</p>
<ul>
<li>blockhash: H256,</li>
<li>metadatablob: Vec<u8>,</li>
<li>client: JsonrpseeClient,</li>
</ul>
<p>outputs:</p>
<ul>
<li>Result&lt;Vec&lt;event_summary&gt;</li>
</ul>
<p>Used in code example:</p>
<p>Special feature flag needed:
Yes - feature = &quot;metadatadecode&quot;</p>
<hr />
<p>Name of Function:
get_block_events
Function description:
Return the PreBlock of the block from the block's hash.<br />
inputs:
blockhash: H256,
client: JsonrpseeClient,</p>
<p>outputs:
Result&lt;PreBlock, crate::error::Error&gt;</p>
<p>Used in code example:</p>
<p>Special feature flag needed:
No</p>
<hr />
<p>Name of Function:
get_latest_finalized_head
Function description:
Get the latest finalized block and return it as a H256 hash.</p>
<p>inputs:
client: JsonrpseeClient,
outputs:
Result&lt;H256, crate::error::Error&gt;
Used in code example:</p>
<p>Special feature flag needed:
No</p>
<hr />
<p>Name of Function:
get_metadata_version</p>
<p>Function description:
Returns the metadata version(1-14)</p>
<p>inputs:
client: JsonrpseeClient
outputs:
u8
Used in code example:</p>
<p>Special feature flag needed:
No</p>
<hr />
<p>Name of Function:<br />
blockhash_to_block<br />
Function description:<br />
Convert a block_hash in H256 format to a <a href="https://docs.rs/libuptest/0.1.1/libuptest/types/struct.PreBlock.html">Preblock</a></p>
<p>inputs:
client: JsonrpseeClient,
block_hash: H256,</p>
<p>outputs:
Preblock</p>
<p>Used in code example:</p>
<p>Special feature flag needed:
No</p>
<hr />
<p>Name of Function:
blocknumber_to_blockhash</p>
<p>Function description:
Convert the block number to a block hash, function queries the chain's chain.getBlockHash endpoint.</p>
<p>inputs:
client: JsonrpseeClient,
block_nr: String,</p>
<p>outputs:
Result&lt;H256, crate::error::Error&gt;</p>
<p>Used in code example:</p>
<p>Special feature flag needed:
No</p>
<hr />
<p>Name of Function:
get_raw_metadata</p>
<p>Function description:
The the chain's metadata in a raw format(Vector of u8's).</p>
<p>inputs:
client: JsonrpseeClient,</p>
<p>outputs:
anyhow::Result&lt;Vec<u8>, crate::error::Error&gt;
Used in code example:</p>
<p>Special feature flag needed:
No</p>
<hr />
<p>Name of Function:
get_metadata_version</p>
<p>Function description:
get the metadata version of chain X</p>
<p>Function description:</p>
<p>inputs:
client: JsonrpseeClient,</p>
<p>outputs:
Result&lt;u8, crate::error::Error&gt;</p>
<p>Used in code example:</p>
<p>Special feature flag needed:
No</p>
<hr />
<p>Add your own custom rpc/ws functions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>libuptest/src/ws_mod.rs:



#[maybe_async::maybe_async(?Send)] /// use maybe-async crate to make the async code a bit easier to work with 
pub async fn get_custom_thing(
    client: JsonrpseeClient,
) -&gt; anyhow::Result&lt;MYTYPE, crate::error::Error&gt; { // replace MYTYPE with the output you wish to get
    let hex_data: String = client
        .request(&quot;chain_getFinalizedHead&quot;, RpcParams::new())// replace chain_getFinalizedHead with module_function, if an input is required, pass it along with rpc_params![input1, input2] instead of RpcParamns::new(), which returns an empty list
        .await?;
    let myoutput: MYTYPE = H256::from_str(&amp;hex_data.as_str())?; // make sure your type matches with the response output, serde comes in very handy for building structs based on the returned json rpc response 
    Ok(myoutput)
}

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libuptest-decoding-extrinsics"><a class="header" href="#libuptest-decoding-extrinsics">Libuptest Decoding Extrinsics</a></h1>
<p>When we query the chain for data we will get the raw data as a response. In order to decode this to a human readable format we need to know the metadata version and decode the hex string together with the raw metadata.</p>
<p>The data is encoded in a format called SCALE (Simple Concatenated Aggregate Little-Endian). The encodment will be a bit different depending on your metadata version(latest and most widely used is V14). </p>
<h3 id="code-sample"><a class="header" href="#code-sample">Code sample:</a></h3>
<pre><pre class="playground"><code class="language-rust">use libuptest::decode_extrinsic::decode_extrinsic_hex_string;
use libuptest::jsonrpseeclient::JsonrpseeClient;
use libuptest::types::event_summary;
use libuptest::ws_mod::get_raw_metadata;

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    // define the raw extrinsic hex string we get from the chain, in this example its a simple time stamp
    let raw_extrinsic = &quot;0x280403000ba0ada8438801&quot;; // time stamp extrinsic taken from random polkadot block
    println!(&quot;Raw extrinsic value: {raw_extrinsic:?}&quot;);
    println!(&quot;Downloading metadata&quot;);
    // download the metadata in a raw u8 Vec 
    let metadata: Vec&lt;u8&gt; = get_raw_metadata(JsonrpseeClient::polkadot_default_url().unwrap())
        .await
        .unwrap(); // yolo
    println!(&quot;Metadata downloaded ok&quot;);
    // once we have the metadata downloaded we want to take that plus our raw extrinsic string and feed it into the decode_extrinsic_hex_string function from Uptest   
    let decoded_output = decode_extrinsic_hex_string(raw_extrinsic, &amp;metadata);
    // use the decoded output and create an event struct from it
    let single_event: event_summary = event_summary {
        pallet_name: decoded_output.call_data.pallet_name.to_string(),
        pallet_method: decoded_output.call_data.ty.name().to_string(),
    };
    let string_vec_events: Vec&lt;event_summary&gt; = vec![single_event];
    // all good, we could now view the data
    println!(
        &quot;Decoded output as:  {:?} &quot;,
        string_vec_events[0].pallet_method
    );
    Ok(())
}
</code></pre></pre>
<h4 id="external-links-1"><a class="header" href="#external-links-1">External links:</a></h4>
<p><a href="https://docs.substrate.io/reference/scale-codec/">docs.substrate.io Scale Encoding</a><br />
<a href="https://github.com/uptest-sc/uptest-sc.github.io/blob/main/markdown/metadata_stats.md">Uptest metadata version scanning survey</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uptest-command-line-tool"><a class="header" href="#uptest-command-line-tool">Uptest command line tool</a></h1>
<blockquote>
<p>Inspiration was taken from <a href="https://en.wikipedia.org/wiki/CURL">Daniel Stenberg's Curl</a> in order to create a command line client that would be flexible and easy for the end user to utilize to send and debug user-defined payloads. Just like Curl we also have Uptest the command line client and Libuptest as the core library like Libcurl.</p>
</blockquote>
<h3 id="get-uptest-command-line-tool"><a class="header" href="#get-uptest-command-line-tool">Get uptest command line tool:</a></h3>
<pre><code class="language-shell">$ git clone https://github.com/uptest-sc/uptest
$ cd uptest/
$ cargo build --release
$ ./target/release/uptest  
</code></pre>
<h3 id="mandoc-for-uptest-cli"><a class="header" href="#mandoc-for-uptest-cli">Mandoc for Uptest-cli</a></h3>
<p><img src="cli/uptest_man.png" alt="Uptest man page" /><br />
Uptest client is built with <a href="cli/">clap</a> and comes prepackaged with clap-mangen. Building uptest manually with cargo will output a mandoc file in the <code>target/man/uptest.man</code> location. Copy it to your mandoc directory which is different depending on what operating system you run.</p>
<h4 id="install-uptest-man-on-debian"><a class="header" href="#install-uptest-man-on-debian">Install uptest .man on debian:</a></h4>
<p>Step 1:<br />
Run mandb to display the man directory path.</p>
<pre><code>$ mandb
Purging old database entries in /home/user/.nvm/versions/node/v17.8.0/share/man...
Processing manual pages under /home/user/.nvm/versions/node/v17.8.0/share/man...
Processing manual pages under /home/user/.nvm/versions/node/v17.8.0/share/man/cat1...
0 man subdirectories contained newer manual pages.
0 manual pages were added.
0 stray cats were added.
0 old database entries were purged.

</code></pre>
<p>Copy over the compiled man pages that was made during the build to your man page path:</p>
<pre><code>$ cp target/release/man/uptest.man  /home/user/.nvm/versions/node/v17.8.0/share/man/uptest.1 
</code></pre>
<p>Rebuild the man cache:</p>
<pre><code>$ mandb  
</code></pre>
<p>If all is well we can now read uptest documentation with <code>man</code>:</p>
<p><code>$ man uptest</code></p>
<p>Code source:<br />
<a href="https://github.com/uptest-sc/uptest/blob/0ba314e0316b57c4999660db378e1fd71bc6f39c/build.rs#L22">uptest cli build script</a></p>
<p><a href="https://man.openbsd.org/">OpenBSD's mandoc search</a><br />
<a href="https://manpages.debian.org/bookworm/cargo/cargo.1.en.html">Debian mandoc search</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="watch-for-runtime-upgrades-and-custom-events"><a class="header" href="#watch-for-runtime-upgrades-and-custom-events">Watch for runtime upgrades and custom events</a></h1>
<p>With uptest cli tool we can subscribe to the latest blocks and check them automatically for a certain event to be triggered. Once uptest finds our user defined event it will return the hash of the block that contains the event.</p>
<h4 id="create-a-custom-event-with-event_summary"><a class="header" href="#create-a-custom-event-with-event_summary">Create a custom event with event_summary:</a></h4>
<pre><code>let detect_event = event_summary {
        pallet_name: &quot;system&quot;.to_string(),
        pallet_method: &quot;setCode&quot;.to_string(),
    }; 
</code></pre>
<h4 id="command-line-client-example"><a class="header" href="#command-line-client-example">Command line client example:</a></h4>
<pre><code>./target/release/uptest -s Sudo sudo_unchecked_weight
Uptest command line tool
Matches: Some(&quot;pallet-method-sub&quot;)
Subscribing to Chain X, Metadata Version Y
Connecting to chain..
Looking for Pallet: &quot;Sudo&quot;
Checking block #&quot;0x0&quot;
Got block events... Decoding it..
Block: 0xab80e34ccc0b1201206b599b2d4e7a455afb9535287a8bfcf209cfb3db1503ca does not contain Pallet: &quot;Sudo&quot; with method: &quot;sudo_unchecked_weight&quot;
Checking block #&quot;0x7&quot;
Got block events... Decoding it..
Block: 0xf455c0485a2b6256b7f1314b1822a8502710e7d2cd710007938f3fc1509dc7ab does not contain Pallet: &quot;Sudo&quot; with method: &quot;sudo_unchecked_weight&quot;
Checking block #&quot;0x8&quot;
Got block events... Decoding it..
Block: 0x75eaf2d2e31cbb8f09706b4341e18c478eb4fc27c30b2060c6c854cfd153f376 does not contain Pallet: &quot;Sudo&quot; with method: &quot;sudo_unchecked_weight&quot;
Checking block #&quot;0x9&quot;
Got block events... Decoding it..
Block: 0x365275bbe42360026843f76d52945c5f4a1f476820a0212630eead7324f634b2 contains event
thread 'main' panicked at 'Exiting..', src/helper.rs:129:17
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>./target/release/uptest -s --help
Uptest command line tool
Usage example: uptest -s Balance transfer 
uptest -s pallet_name pallet_method
$ ./target/release/uptest -s balance transfer   
<span class="boring">}</span></code></pre></pre>
<p>Note:
The -s flag is case sensitive.</p>
<h4 id="example-from-code-examples"><a class="header" href="#example-from-code-examples">Example from code examples:</a></h4>
<p><a href="https://uptest-sc.github.io/code_samples/upgrade_change_diff.html">https://uptest-sc.github.io/code_samples/upgrade_change_diff.html</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subscribe-to-block-events"><a class="header" href="#subscribe-to-block-events">Subscribe to block events</a></h1>
<p>One of uptest-cli features is to subscribe to a chain, wait for the latest finalized blocks and display the events triggered in each new block. </p>
<h3 id="uptest-command-line-client--w"><a class="header" href="#uptest-command-line-client--w">Uptest command line client -w</a></h3>
<pre><code class="language-shell">./target/release/uptest -w --help
Uptest command line tool
Usage example: uptest -w wshost blockamount
            
 Connect to polkadot and view the latest 40 blocks: uptest -w wss://polkadot-rpc-tn.dwellir.com:443 40 
            
 Latest 50 blocks from the locally running substrate node: ./target/release/uptest -w ws://127.0.0.1:9944 50
</code></pre>
<pre><code class="language-shell">./target/release/uptest -w wss://polkadot-rpc-tn.dwellir.com:443 40 
Uptest command line tool
Subscribing to latest finalized blocks at &quot;wss://polkadot-rpc-tn.dwellir.com:443&quot;
------------------------------------------------
Latest finalized block number: 0xfad2a1
Finalized block hash: 0xf8964fcc85bf7cc2edb793de86c78c912564754296806eddb1fa3e10a77781d2
[Triggered event] Pallet: Timestamp triggered event: Timestamp
[Triggered event] Pallet: ParaInherent triggered event: ParaInherent
[Triggered event] Pallet: Balances triggered event: Balances
------------------------------------------------

------------------------------------------------
Latest finalized block number: 0xfad2a2
Finalized block hash: 0x4fad277ab178625fec06fc156df24e4dad993f8bc100fa3a9b1adb96950509a0
[Triggered event] Pallet: Timestamp triggered event: Timestamp
[Triggered event] Pallet: ParaInherent triggered event: ParaInherent
------------------------------------------------

------------------------------------------------
Latest finalized block number: 0xfad2a3
Finalized block hash: 0xe1c13553b68688162f66f0e3a837357dc7b5ed0b88ab19d7ea4139ea5a48be7c
[Triggered event] Pallet: Timestamp triggered event: Timestamp
[Triggered event] Pallet: ParaInherent triggered event: ParaInherent
[Triggered event] Pallet: Balances triggered event: Balances
------------------------------------------------
</code></pre>
<h3 id="code-example"><a class="header" href="#code-example">Code example:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// get blocknr from subscription
println!(&quot;Latest finalized block number: #{}&quot;, blocknr);
let blockhash: H256 = blocknumber_to_blockhash(tmp_client.clone(), blocknr.clone())
    .await
    .unwrap();
println!(&quot;Finalized block hash: {blockhash:?}&quot;);

let preblock = get_block_events(blockhash, tmp_client).await.unwrap();

let extrinsics = preblock.block.extrinsics;

let decodedevent_list: Vec&lt;event_summary&gt; =  extrinsics.clone()
              .iter()
              .map(| n | { decodec_to_event_summary(
                       decode_extrinsic_hex_string(n.as_str(), &amp;metadatablob))})
              .collect();

    for eventet in decodedevent_list.into_iter() {
        println !(&quot;[Triggered event] Pallet: {} triggered event: {}&quot;,
                  eventet.pallet_name, eventet.pallet_name);
      }

<span class="boring">}</span></code></pre></pre>
<h4 id="source-code"><a class="header" href="#source-code">Source code:</a></h4>
<p><a href="https://github.com/uptest-sc/uptest/blob/main/examples/examples/sub_events.rs">uptest/examples/examples/sub_events.rs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libuptest-code-examples"><a class="header" href="#libuptest-code-examples">Libuptest code examples</a></h1>
<p>Libuptest comes with multiple code examples. See the full list here:<br />
<a href="https://github.com/uptest-sc/uptest/tree/main/examples/examples">https://github.com/uptest-sc/uptest/tree/main/examples/examples</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="check-added-and-changed-storage-items-after-a-runtime-upgrade"><a class="header" href="#check-added-and-changed-storage-items-after-a-runtime-upgrade">Check added and changed storage items after a runtime upgrade</a></h1>
<p>is a crucial part of doing runtime upgrades. Their are several ways to detect storage changes with Uptest.</p>
<h3 id="the-simpliest-way-is-to-follow-our-code-example-upgrade_change_diff"><a class="header" href="#the-simpliest-way-is-to-follow-our-code-example-upgrade_change_diff">The simpliest way is to follow our code example <code>upgrade_change_diff</code>:</a></h3>
<h3 id="spin-up-a-substrate-based-node"><a class="header" href="#spin-up-a-substrate-based-node">Spin up a substrate based node:</a></h3>
<pre><code class="language-shell">git clone https://github.com/substrate-developer-hub/substrate-node-template
cd substrate-node-template/ &amp;&amp; cargo build --release
./target/release/node-template --dev --ws-external --
</code></pre>
<p><img src="code_samples/first_run.png" alt="Start a substrate node" title="Start a substrate based node" /></p>
<h3 id="run-our-code-example"><a class="header" href="#run-our-code-example">Run our code example:</a></h3>
<pre><code class="language-shell">$ git clone https://github.com/uptest-sc/uptest/ &amp;&amp; cd uptest
$ cargo run -p uptest-examples --example upgrade_change_diff
    Finished dev [unoptimized + debuginfo] target(s) in 0.26s
     Running `target/debug/examples/upgrade_change_diff`
Connected to: &quot;node-template&quot;  Runtime version: 106
Waiting for custom event to be triggered
</code></pre>
<h3 id="make-changes-to-the-node-repo-and-change-spec_version"><a class="header" href="#make-changes-to-the-node-repo-and-change-spec_version">Make changes to the node repo and change spec_version:</a></h3>
<p>Make the changes you wish to do, in this example we have changed one storage map and added a storage value to the default template module you can find in the substrate-node-template repo.<br />
Compile the node with the saved changes and get the <code>target/release/wbuild/*.compressed.wasm</code> file.</p>
<h3 id="submit-the-runtime-upgradein-our-example-with-the-sudo-key-and-polkadotjsapps-webui"><a class="header" href="#submit-the-runtime-upgradein-our-example-with-the-sudo-key-and-polkadotjsapps-webui">Submit the runtime upgrade(in our example with the Sudo key and polkadot.js.apps webui):</a></h3>
<p><img src="code_samples/second_run.png" alt="polkadot.js apps" title="polkadot.js" /></p>
<p>Head back to your terminal and you should see that we are able to detect that our custom event has been triggered and we should get the following output:</p>
<pre><code>Event detected in block: 0xf28159f44e72b1859a1b5fb1ff210401605b100300ed53058b939ad2c817faf4
Having a coffee break before next block...
Scanning the new metadata for changes
Runtime upgraded from version: 106 to new version: 107
Changed StorageMap: &quot;SomeMapthree&quot; in Pallet: &quot;TemplateModule&quot; to the new type: Primitive(U32)
Pallet: &quot;TemplateModule&quot; has added a StorageValue with the type: Primitive(Bool)
</code></pre>
<h3 id="external-links-2"><a class="header" href="#external-links-2">External links:</a></h3>
<p><a href="https://github.com/substrate-developer-hub/substrate-node-template">https://github.com/substrate-developer-hub/substrate-node-template</a><br />
<a href="https://github.com/uptest-sc/uptest">Uptest github</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-libuptest-with-subxt"><a class="header" href="#using-libuptest-with-subxt">Using Libuptest with Subxt</a></h1>
<p>Their are multiple ways of utilizing Libuptest combined with Subxt.</p>
<h3 id="with-event_watch"><a class="header" href="#with-event_watch">With event_watch:</a></h3>
<p>Code example:</p>
<pre><code class="language-toml">$ cat Cargo.toml
[package]
name = &quot;wait_for_event_then_submit_tx&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
subxt = &quot;0.29.0&quot;
subxt-macro = &quot;0.29.0&quot;
subxt-metadata = &quot;0.29.0&quot;
tokio = { version = &quot;1.29.1&quot;, features = [&quot;full&quot;] }
sp-keyring = &quot;24.0.0&quot; 
sp-runtime = &quot;24.0.0&quot;
libuptest = { git = &quot;https://github.com/uptest-sc/uptest/&quot;, branch = &quot;main&quot;, features = [&quot;metadatadecode&quot;]}
</code></pre>
<p>src/main.rs:</p>
<pre><pre class="playground"><code class="language-rust">use libuptest::jsonrpseeclient::JsonrpseeClient;
use libuptest::types::{event_summary, H256};
use libuptest::ws_mod::event_watch;
use sp_keyring::AccountKeyring;
use subxt::{tx::PairSigner, OnlineClient, PolkadotConfig};

/// connect to substrate node template
#[subxt::subxt(runtime_metadata_url = &quot;ws://127.0.0.1:9944&quot;)]
mod nodetemplate {}

/// simple transfer function that will block until the user defined event is triggered
/// run an async task in a
pub async fn run_after_event() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // wait and check the next 200 blocks
    let amount_of_blocks_to_queue_for: u32 = 200u32;
    // connect to chain at 127.0.0.1:9944
    let client = JsonrpseeClient::with_default_url().unwrap();
    // create an event we want to watch for then send our tx
    let event_to_wait_for: event_summary = event_summary {
        pallet_name: &quot;Sudo&quot;.to_string(),
        pallet_method: &quot;sudo_unchecked_weight&quot;.to_string(),
    };

    println!(&quot;waiting..&quot;);
    /// wait until the event is called and we get the block hash of the block that triggered the event
    match event_watch(client, event_to_wait_for, amount_of_blocks_to_queue_for).await {
        Ok(value) =&gt; {
            println!(&quot;Found event in block: {:?}&quot;, value);
            let _tx = send_tx().await;
            println!(&quot;all good&quot;);
        }
        _ =&gt; {
            println!(&quot;Event find failed..&quot;);
        }
    };
    println!(&quot;all good&quot;);
    Ok(())
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let result = run_after_event().await;
    Ok(())
}

/// send a balance transfer from Alice to Bob
async fn send_tx() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create a new API client, configured to talk to Polkadot nodes.
    let api = OnlineClient::&lt;PolkadotConfig&gt;::new().await?;

    // Build a balance transfer extrinsic.
    let dest = AccountKeyring::Bob.to_account_id().into();
    let balance_transfer_tx = nodetemplate::tx().balances().transfer(dest, 10_000);

    // Submit the balance transfer extrinsic from Alice, and wait for it to be successful
    let from = PairSigner::new(AccountKeyring::Alice.pair());
    println!(&quot;sending tx&quot;);
    let _output = api
        .tx()
        .sign_and_submit_then_watch_default(&amp;balance_transfer_tx, &amp;from)
        .await?
        .wait_for_finalized_success()
        .await?;
    println!(&quot;tx sent&quot;);

    Ok(())
}

</code></pre></pre>
<h3 id="external-links-3"><a class="header" href="#external-links-3">External links:</a></h3>
<p><a href="https://github.com/paritytech/subxt">https://github.com/paritytech/subxt</a><br />
<a href="https://docs.rs/subxt/latest/subxt/book/index.html">Subxt Guide</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libuptest-random-input-generation"><a class="header" href="#libuptest-random-input-generation">Libuptest random input generation</a></h1>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use libuptest::test_helper::InputHelper;
<span class="boring">}</span></code></pre></pre>
<h3 id="generate-u128-u64-u32-u8"><a class="header" href="#generate-u128-u64-u32-u8">Generate u128, u64, u32, u8:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let rand_u128: u128 = InputHelper::get_u128();
println!(&quot;u128: {}&quot;, rand_u128);
let rand_u64: u64 = InputHelper::get_u64();
println!(&quot;u64: {}&quot;, rand_u64);
let rand_u32: u32 = InputHelper::get_u32();
println!(&quot;u32: {}&quot;, rand_u32);
let rand_u8: u8 = InputHelper::get_u8();
println!(&quot;u8: {}&quot;, rand_u8);
<span class="boring">}</span></code></pre></pre>
<h5 id="output"><a class="header" href="#output">Output:</a></h5>
<pre><code>u128: 225864167899979897207776191162143802327
u64: 15697195152894034115
u32: 986567393
u8: 247
</code></pre>
<h3 id="generate-f32-and-f64"><a class="header" href="#generate-f32-and-f64">Generate f32 and f64:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let rand_f64: f64 = InputHelper::get_f64();
println!(&quot;f64: {}&quot;, rand_f64);
let rand_f32: f32 = InputHelper::get_f32();
println!(&quot;f32: {}&quot;, rand_f32);
<span class="boring">}</span></code></pre></pre>
<h5 id="output-1"><a class="header" href="#output-1">Output:</a></h5>
<pre><code>f64: 0.07036028431640629
f32: 0.48309267
</code></pre>
<h3 id="generate-boolean"><a class="header" href="#generate-boolean">Generate boolean:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let rand_boolean: bool = InputHelper::get_boolean();
println!(&quot;boolean: {}&quot;, rand_boolean);
<span class="boring">}</span></code></pre></pre>
<h5 id="output-2"><a class="header" href="#output-2">Output:</a></h5>
<pre><code>boolean: true
</code></pre>
<h3 id="generate-addressesaccountid32"><a class="header" href="#generate-addressesaccountid32">Generate Addresses/AccountId32:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let rand_address = InputHelper::get_address();
println!(&quot;Address: {}&quot;, rand_address.to_string());
<span class="boring">}</span></code></pre></pre>
<h5 id="output-3"><a class="header" href="#output-3">Output:</a></h5>
<pre><code>Address: 5HjAev48u9TC5A3QAyu8WBZuWo4asVx1Z72jNoNcAWzsZpU8
</code></pre>
<h4 id="documentation"><a class="header" href="#documentation">Documentation:</a></h4>
<p><a href="https://docs.rs/libuptest/latest/libuptest/test_helper/struct.InputHelper.html">https://docs.rs/libuptest/latest/libuptest/test_helper/struct.InputHelper.html</a>
<a href="https://github.com/uptest-sc/uptest/blob/main/examples/examples/test_input_gen.rs">Libuptest random input example code</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libuptest-in-action"><a class="header" href="#libuptest-in-action">Libuptest in Action</a></h1>
<p>This chapter walks you hand in hand on how you can utilize uptest to prevent bad upgrades from happening.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-1-preventing-breaking-upgrades"><a class="header" href="#tutorial-1-preventing-breaking-upgrades">Tutorial #1 preventing breaking upgrades</a></h1>
<h3 id="summary"><a class="header" href="#summary">Summary:</a></h3>
<p>In this tutorial we will take a look on how you can utilize uptest-cli to detect storage changes and how the chain can break if those are not migrated properly. Three runtime upgrades will be pushed, changing the type of a storage value, then inproperly <code>unwraping</code> the new value without migrating it. </p>
<h4 id="requirements"><a class="header" href="#requirements">Requirements:</a></h4>
<ul>
<li>Rust and Cargo</li>
<li>git</li>
<li><a href="https://github.com/uptest-sc/uptest">uptest-cli</a><br />
<code>$ git clone https://github.com/uptest-sc/uptest &amp;&amp; cd uptest/ &amp;&amp; cargo build --release</code></li>
<li><a href="https://github.com/uptest-sc/submit-runtime-upgrade">submit-runtime-upgrade</a><br />
<code>$ git clone https://github.com/uptest-sc/submit-runtime-upgrade &amp;&amp; cd submit-runtime-upgrade/ &amp;&amp; cargo build --release</code></li>
</ul>
<h2 id="step-one"><a class="header" href="#step-one">Step one:</a></h2>
<p>Clone and compile substrate-node-template-hack</p>
<pre><code>$ git clone -b tutorial_1 https://github.com/uptest-sc/substrate-node-template-hack
$ cd substrate-node-template-hack/  
</code></pre>
<h4 id="change-the-spec_version-to-100"><a class="header" href="#change-the-spec_version-to-100">Change the spec_version to 100:</a></h4>
<p>Head over to <code>runtime/src/lib.rs</code> and edit spec_version to 100.</p>
<h4 id="compile-the-node"><a class="header" href="#compile-the-node">Compile the node:</a></h4>
<p><code>$ cargo build --release</code></p>
<h4 id="copy-the-binary-to-another-file"><a class="header" href="#copy-the-binary-to-another-file">Copy the binary to another file:</a></h4>
<p><code>cp target/release/substrate-node-template version_100 </code></p>
<h4 id="start-the-node"><a class="header" href="#start-the-node">Start the node:</a></h4>
<p><code>$ RUST_LOG=runtime=debug ./version_100 --dev --ws-external --base-path=/tmp/temp_node</code></p>
<h4 id="verify-that-spec_version-is-100"><a class="header" href="#verify-that-spec_version-is-100">Verify that spec_version is 100</a></h4>
<pre><code>./target/release/uptest -i ws://127.0.0.1:9944
Uptest command line tool
----Chain-Info----
Chain Name: &quot;node-template&quot;
Runtime version: 100
Authoring Version: 1
State Version: 1
--E-O-L--
</code></pre>
<h2 id="step-two"><a class="header" href="#step-two">Step two:</a></h2>
<h4 id="change-the-spec_version-to-101"><a class="header" href="#change-the-spec_version-to-101">Change the spec_version to 101:</a></h4>
<p>Head over to <code>runtime/src/lib.rs</code> and edit spec_version to 101.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[sp_version::runtime_version]
pub const VERSION: RuntimeVersion = RuntimeVersion {
	spec_name: create_runtime_str!(&quot;node-template&quot;),
	impl_name: create_runtime_str!(&quot;node-template&quot;),
	authoring_version: 1,
	spec_version: 100, // change me to 101
	impl_version: 3,
	apis: RUNTIME_API_VERSIONS,
	transaction_version: 1,
	state_version: 1,
};
<span class="boring">}</span></code></pre></pre>
<p><a href="https://github.com/uptest-sc/substrate-node-template-hack/blob/tutorial_1/runtime/src/lib.rs#L106C2-L106C14">https://github.com/uptest-sc/substrate-node-template-hack/blob/tutorial_1/runtime/src/lib.rs#L106C2-L106C14</a></p>
<h4 id="modify-pallet-template"><a class="header" href="#modify-pallet-template">Modify Pallet-template</a></h4>
<p>We are going to be focusing on a storage item in pallet-template. 
Our example storage item is the <code>Something2</code> storageValue:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[pallet::storage]
#[pallet::getter(fn something2)]
pub type Something2&lt;T&gt; = StorageValue&lt;_, u64&gt;;
<span class="boring">}</span></code></pre></pre>
<p>We want to change the storage type from a u64 to a boolean:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[pallet::storage]
#[pallet::getter(fn something2)]
pub type Something2&lt;T&gt; = StorageValue&lt;_, bool&gt;;
<span class="boring">}</span></code></pre></pre>
<p>Change the on_initialize function from u64 to bool type, this function runs on the start of every block:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_initialize(n: BlockNumberFor&lt;T&gt;) -&gt; Weight {
			let printme = format!(&quot;on_initialize(#{:?})&quot;, n);
			print(printme.as_str());
			let second: Option&lt;u64&gt; = Something2::&lt;T&gt;::get(); //bool here
//			let to_print: u64 = second.unwrap();//change me to bool
			let sp = format!(&quot;second is: {:?}&quot;, second);
			print(sp.as_str());
			Weight::from_parts(2175, 0)
		}

<span class="boring">}</span></code></pre></pre>
<p>Change the do_something_second function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn do_something_second(origin: OriginFor&lt;T&gt;, something2: u64) -&gt; DispatchResult { // change me
			let who = ensure_signed(origin)?;
			&lt;Something2&lt;T&gt;&gt;::put(something2);
			Ok(())
		}
<span class="boring">}</span></code></pre></pre>
<h4 id="start-the-node-with-the-copied-binary-and-the-same-base-path"><a class="header" href="#start-the-node-with-the-copied-binary-and-the-same-base-path">Start the node with the copied binary and the same base-path:</a></h4>
<p><code>$ RUST_LOG=runtime=debug ./version_100 --dev --ws-external --base-path=/tmp/temp_node</code></p>
<pre><code>…1cec), ⬇ 0 ⬆ 0
INFO tokio-runtime-worker sc_basic_authorship::basic_authorship: 🙌 Startin
p of parent 0x6a60f1d4241c4678f6a860edea30a13ab4903a0a5414ea31a521eb8d625df

EBUG tokio-runtime-worker runtime: on_initialize(#2)                      
EBUG tokio-runtime-worker runtime: second is: None                        
EBUG tokio-runtime-worker runtime: Finalized block: #2                    
EBUG tokio-runtime-worker runtime::system: [2] 0 extrinsics, length: 11 (no
</code></pre>
<p>The node should start and should be able to see the value of <em>Something2</em> storage item in the logs.</p>
<h2 id="step-three"><a class="header" href="#step-three">Step three:</a></h2>
<p>Head over to Polkadot.js.apps and connect to your chain. Then go to Developer &gt; extrinsics &gt; Pallet templateModule and function doSomethingSecond and set the boolean to true. Submit the transaction and in your node log file you should see that the value is set to true in your logs.</p>
<h2 id="step-four"><a class="header" href="#step-four">Step four:</a></h2>
<p>Now we have two version of our node, version 100 that is running and our new version, the 101.</p>
<h4 id="use-uptest-cli-to-display-changes-made"><a class="header" href="#use-uptest-cli-to-display-changes-made">Use uptest-cli to display changes made</a></h4>
<p>Use uptest-cli with the '-c' flag to see changes made, we want to start this before we push the upgrade and then check back once we have pushed the upgrade:</p>
<pre><code>./target/release/uptest  -c ws://127.0.0.1:9944
Uptest command line tool
running ws host: &quot;ws://127.0.0.1:9944&quot;
Connected to chain
Gathered current storage types
Waiting for runtime upgrade
</code></pre>
<h4 id="we-now-want-to-push-a-runtime-upgrade"><a class="header" href="#we-now-want-to-push-a-runtime-upgrade">We now want to push a runtime upgrade.</a></h4>
<p>Clone the <a href="https://github.com/uptest-sc/submit-runtime-upgrade">submit-runtime-upgrade</a> repo. Modify it to your needs and compile it.</p>
<p>Run it:</p>
<pre><code>./target/release/submit-runtime-upgrade 
Current Runtime Version: 100
sending tx
Sent tx: 0xb91bc8ed09a7a3e0accbaa92720412f382f4ae211218acece279a251bd67189c
Runtime Version changed from 100 to 101
</code></pre>
<h4 id="check-back-at-uptest-cli"><a class="header" href="#check-back-at-uptest-cli">Check back at uptest-cli</a></h4>
<p>The rest of our output should have been caught by uptest now:</p>
<pre><code>./target/release/uptest  -c ws://127.0.0.1:9944
...
Runtime upgrade in block: 0xb91bc8ed09a7a3e0accbaa92720412f382f4ae211218acece279a251bd67189c
Having a coffee break before next block...
Scanning the new metadata for changes
Runtime upgraded from version: 108 to new version: 109
Pallet name:  &quot;TemplateModule&quot;
    Storage item name:  &quot;Something2&quot; 
    Storage item type:  StorageValue 
    Old storage type:  Primitive(U64)
    New storage type: Primitive(bool)

</code></pre>
<h4 id="check-the-spec_version-with-uptest"><a class="header" href="#check-the-spec_version-with-uptest">Check the spec_version with uptest:</a></h4>
<p>We want to make sure our chain has started and that the correct spec_version was set.</p>
<pre><code>./target/release/uptest -i ws://127.0.0.1:9944
Uptest command line tool
----Chain-Info----
Chain Name: &quot;node-template&quot;
Runtime version: 101
Authoring Version: 1
State Version: 1
--E-O-L--
</code></pre>
<h2 id="step-five"><a class="header" href="#step-five">Step five:</a></h2>
<p>Now we pushed the runtime upgrade but not migrated the data stored so we should still have the bool stored where it's now u64. </p>
<h4 id="change-the-spec_version-to-102"><a class="header" href="#change-the-spec_version-to-102">Change the spec_version to 102:</a></h4>
<p><code>runtime/src/lib.rs</code> and edit spec_version to 102.</p>
<p>Create an unwrap statement to assume that our value is set to a u64.: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_initialize(n: BlockNumberFor&lt;T&gt;) -&gt; Weight {
			let printme = format!(&quot;on_initialize(#{:?})&quot;, n);
			print(printme.as_str());
			let second: Option&lt;u64&gt; = Something2::&lt;T&gt;::get(); //bool here
//			let to_print: u64 = second.unwrap();//change me to bool
			let sp = format!(&quot;second is: {:?}&quot;, second);
			print(sp.as_str());
			Weight::from_parts(2175, 0)
		}

<span class="boring">}</span></code></pre></pre>
<p>Push the runtime upgrade just like you did previously with submite-runtime-upgrade.</p>
<p>restart node and you should see it fail:</p>
<pre><code>ces
DEBUG tokio-runtime-worker runtime::frame-support: ✅ no migration for TransactionPayment
DEBUG tokio-runtime-worker runtime::frame-support: ✅ no migration for Sudo
 DEBUG tokio-runtime-worker runtime::frame-support: ✅ no migration for TemplateModule
 DEBUG tokio-runtime-worker runtime: on_initialize(#672)                    
 ERROR tokio-runtime-worker runtime::storage: Corrupted state at `[23, 126, 104, 87, 251, 29, 14, 64, 147, 118, 18, 47, 238, 58, 212, 248, 59, 217, 88, 236, 134, 13, 139, 180, 170, 77, 234, 152, 3, 48, 17, 235]: Error`
 ERROR tokio-runtime-worker runtime: panicked at 'called `Option::unwrap()` on a `None` value', /tmp/substrate-node-template/pallets/template/src/lib.rs:46:40                  
  WARN tokio-runtime-worker aura: Proposing failed: Import failed: Error at calling runtime api: Execution failed: Execution aborted due to trap: wasm trap: wasm `unreachable` instruction executed
WASM backtrace:
error while executing at wasm backtrace:
    0: 0x641a8 - &lt;unknown&gt;!rust_begin_unwind
    1: 0x2938 - &lt;unknown&gt;!core::panicking::panic_fmt::hca80ede79c2b9c5b                            
    2: 0x298b - &lt;unknown&gt;!core::panicking::panic::hed93247151462aff                                
    3: 0x1ccc5 - &lt;unknown&gt;!&lt;pallet_template::pallet::Pallet&lt;T&gt; as frame_support::traits::hooks::OnInitialize&lt;&lt;T as frame_system::pallet::Config&gt;::BlockNumber&gt;&gt;::on_initialize::h493bf697531cf5b3      
    4: 0x25a40 - &lt;unknown&gt;!frame_executive::Executive&lt;System,Block,Context,UnsignedValidator,AllPalletsWithSystem,COnRuntimeUpgrade&gt;::initialize_block::h066e78a766ca61bb                              
    5: 0x4900e - &lt;unknown&gt;!Core_initialize_block
note: using the `WASMTIME_BACKTRACE_DETAILS=1` environment variable may show more debugging information
2023-07-28 13:16:36.194  INFO tokio-runtime-worker substrate: 💤 Idle (0 peers), best: #671 (0x2b63…7b5f), finalized #669 (0xd406…b775), ⬇ 0 ⬆ 0
</code></pre>
<p>Block production have now stopped</p>
<h2 id="wip-tutorial"><a class="header" href="#wip-tutorial">WIP tutorial</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="submitting-runtime-upgrades"><a class="header" href="#submitting-runtime-upgrades">Submitting runtime upgrades</a></h1>
<p>There are 2 main ways of submitting a runtime upgrade:</p>
<h3 id="sudo"><a class="header" href="#sudo">Sudo:</a></h3>
<p>If the chain has a sudo key enabled, comonly enabled by dev chainspec's. A <code> System::SetCode</code> wrapped in a <code>Sudo sudo_unchecked_weight</code> transaction can overwrite the runtime and trigger a runtime upgrade with the submitted wasm file submitted with the setcode transaction.</p>
<p>Code example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::Path;
use libuptest::metadata::read_wasm_binary_correct;
use subxt::{OnlineClient, PolkadotConfig};
...

let wasm_path = Path::new(&quot;/tmp/substrate-node-template/target/release/wbuild/node-template-runtime/node_template_runtime.compact.wasm&quot;);
// read binary
let code: Vec&lt;u8&gt; = read_wasm_binary_correct(wasm_path).await;
// create system set_code call
let call = nodetemplate::runtime_types::node_template_runtime::RuntimeCall::System(
SystemCall::set_code {
    code: code.into(),
},
); //Call::System(
let weight = Weight {
ref_time: 0,
proof_size: 0,
};

// create the sudo tx
let sudo_tx = nodetemplate::tx()
.sudo()
.sudo_unchecked_weight(call, weight);
<span class="boring">}</span></code></pre></pre>
<p>Source code:<br />
<a href="https://github.com/uptest-sc/submit-runtime-upgrade">https://github.com/uptest-sc/submit-runtime-upgrade</a></p>
<h3 id="democracy-vote"><a class="header" href="#democracy-vote">Democracy vote:</a></h3>
<h4 id="create-a-preimage-of-the-runtime-upgrade-set-code"><a class="header" href="#create-a-preimage-of-the-runtime-upgrade-set-code">Create a preimage of the runtime upgrade set code:</a></h4>
<p>The user can submit a preimaged of the system setcode call. Then submit the preimage to democracy by submitting a democracy &gt; note preimage transaction. </p>
<h4 id="submit-the-preimage-for-a-democracy-vote"><a class="header" href="#submit-the-preimage-for-a-democracy-vote">Submit the preimage for a democracy vote</a></h4>
<p>Make a democracy &gt; propose transaction with your preimage hash.<br />
Your proposal is now created!</p>
<h4 id="get-votes"><a class="header" href="#get-votes">Get votes!</a></h4>
<p>All you need to do now is to get enough votes for your proposal so the chain will execute it. If you are running a dev node we recommend modifying the time lenght for the life cycle of a proposal to make debugging faster and easier. </p>
<h2 id="note"><a class="header" href="#note">Note:</a></h2>
<p>Chains differentiate in how you submit the upgrade, depending on implementation.<br />
If you have a chain that submits a runtime upgrade in a different way, submit a pr:<br />
<a href="https://github.com/uptest-sc/uptest-sc.github.io/pulls">https://github.com/uptest-sc/uptest-sc.github.io/pulls</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="real-chains-breaking---case-studies"><a class="header" href="#real-chains-breaking---case-studies">Real chains breaking - Case studies</a></h1>
<p>This chapter will focus on upgrades that have taken place on live networks that have caused live chains to stop producing blocks.</p>
<p>Submit tips here:<br />
<a href="https://github.com/uptest-sc/uptest-sc.github.io/issues/12">https://github.com/uptest-sc/uptest-sc.github.io/issues/12</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="automatically-generate-tests"><a class="header" href="#automatically-generate-tests">Automatically generate tests</a></h1>
<p>Libuptest supports automatically generating suggested ways to query each storage item.<br />
This can be used to make writing tests faster.</p>
<h3 id="libuptest"><a class="header" href="#libuptest">Libuptest:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use libuptest::test_generation::autogen::{generate_auto_test, generate_test_std, AutoTestSummary, AutoTests};
<span class="boring">}</span></code></pre></pre>
<h3 id="uptest-cli"><a class="header" href="#uptest-cli">Uptest-cli:</a></h3>
<pre><code class="language-shell">$ uptest-cli -a ws://127.0.0.1:9944
</code></pre>
<p>Let's explore them more indept in the next part.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uptest-cli-auto-test"><a class="header" href="#uptest-cli-auto-test">uptest-cli auto-test</a></h1>
<pre><code class="language-shell">$ uptest-cli -a ws://127.0.0.1:9944
Uptest command line tool
Connect to chain
Scanning storage...
Pallet: &quot;System&quot;
Raw Type: Composite(TypeDefComposite { fields: [Field { name: Some(&quot;nonce&quot;), ty: UntrackedSymbol { id: 4, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;Index&quot;), docs: [] }, Field { name: Some(&quot;consumers&quot;), ty: UntrackedSymbol { id: 4, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;RefCount&quot;), docs: [] }, Field { name: Some(&quot;providers&quot;), ty: UntrackedSymbol { id: 4, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;RefCount&quot;), docs: [] }, Field { name: Some(&quot;sufficients&quot;), ty: UntrackedSymbol { id: 4, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;RefCount&quot;), docs: [] }, Field { name: Some(&quot;data&quot;), ty: UntrackedSymbol { id: 5, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;AccountData&quot;), docs: [] }] })
Storage Item name &quot;Account&quot;
Storage Item type StorageMap
Code:
random input is: &quot;let output: Index = query_storage_map(Account)&quot;
-------------------
Pallet: &quot;System&quot;
Raw Type: Primitive(U32)
Storage Item name &quot;ExtrinsicCount&quot;
Storage Item type StorageValue
Code:
fn submit_to_ExtrinsicCount(testinput)
random input is: &quot;let testinput: u32 = 4156112247u32&quot;
-------------------
Pallet: &quot;System&quot;
Raw Type: Composite(TypeDefComposite { fields: [Field { name: Some(&quot;normal&quot;), ty: UntrackedSymbol { id: 8, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;T&quot;), docs: [] }, Field { name: Some(&quot;operational&quot;), ty: UntrackedSymbol { id: 8, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;T&quot;), docs: [] }, Field { name: Some(&quot;mandatory&quot;), ty: UntrackedSymbol { id: 8, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;T&quot;), docs: [] }] })
Storage Item name &quot;BlockWeight&quot;
Storage Item type StorageValue
Code:
random input is: &quot;let output: T = query_storage_map(BlockWeight)&quot;
-------------------
Pallet: &quot;System&quot;
Raw Type: Primitive(U32)
Storage Item name &quot;AllExtrinsicsLen&quot;
Storage Item type StorageValue
Code:
fn submit_to_AllExtrinsicsLen(testinput)
random input is: &quot;let testinput: u32 = 3905420446u32&quot;
-------------------
Pallet: &quot;System&quot;
Raw Type: Composite(TypeDefComposite { fields: [Field { name: None, ty: UntrackedSymbol { id: 1, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;[u8; 32]&quot;), docs: [] }] })
Storage Item name &quot;BlockHash&quot;
Storage Item type StorageMap
Code:
random input is: &quot;let output: [u8; 32] = query_storage_map(BlockHash)&quot;
-------------------
Pallet: &quot;System&quot;
Raw Type: Sequence(TypeDefSequence { type_param: UntrackedSymbol { id: 2, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; } })
Storage Item name &quot;ExtrinsicData&quot;
Storage Item type StorageMap
Code:
random input is: &quot;let Query_chain_state = System.ExtrinsicData(); // query the StorageMap | Sequence storage type&quot;
-------------------
Pallet: &quot;System&quot;
Raw Type: Primitive(U32)
Storage Item name &quot;Number&quot;
Storage Item type StorageValue
Code:
fn submit_to_Number(testinput)
random input is: &quot;let testinput: u32 = 1953627433u32&quot;
-------------------
Pallet: &quot;System&quot;
Raw Type: Composite(TypeDefComposite { fields: [Field { name: None, ty: UntrackedSymbol { id: 1, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;[u8; 32]&quot;), docs: [] }] })
Storage Item name &quot;ParentHash&quot;
Storage Item type StorageValue
Code:
random input is: &quot;let output: [u8; 32] = query_storage_map(ParentHash)&quot;
-------------------
Pallet: &quot;System&quot;
Raw Type: Composite(TypeDefComposite { fields: [Field { name: Some(&quot;logs&quot;), ty: UntrackedSymbol { id: 14, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;Vec&lt;DigestItem&gt;&quot;), docs: [] }] })
Storage Item name &quot;Digest&quot;
Storage Item type StorageValue
Code:
random input is: &quot;let output: Vec&lt;DigestItem&gt; = query_storage_map(Digest)&quot;
-------------------
Pallet: &quot;System&quot;
Raw Type: Sequence(TypeDefSequence { type_param: UntrackedSymbol { id: 18, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; } })
Storage Item name &quot;Events&quot;
Storage Item type StorageValue
Code:
random input is: &quot;let Query_chain_state = System.Events(); // query the StorageValue | Sequence storage type&quot;
-------------------
Pallet: &quot;System&quot;
Raw Type: Primitive(U32)
Storage Item name &quot;EventCount&quot;
Storage Item type StorageValue
Code:
fn submit_to_EventCount(testinput)
random input is: &quot;let testinput: u32 = 770744696u32&quot;
-------------------
Pallet: &quot;System&quot;
Raw Type: Sequence(TypeDefSequence { type_param: UntrackedSymbol { id: 45, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; } })
Storage Item name &quot;EventTopics&quot;
Storage Item type StorageMap
Code:
random input is: &quot;let Query_chain_state = System.EventTopics(); // query the StorageMap | Sequence storage type&quot;
-------------------
Pallet: &quot;System&quot;
Raw Type: Composite(TypeDefComposite { fields: [Field { name: Some(&quot;spec_version&quot;), ty: UntrackedSymbol { id: 47, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;codec::Compact&lt;u32&gt;&quot;), docs: [] }, Field { name: Some(&quot;spec_name&quot;), ty: UntrackedSymbol { id: 48, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;sp_runtime::RuntimeString&quot;), docs: [] }] })
Storage Item name &quot;LastRuntimeUpgrade&quot;
Storage Item type StorageValue
Code:
random input is: &quot;let output: codec::Compact&lt;u32&gt; = query_storage_map(LastRuntimeUpgrade)&quot;
-------------------
Pallet: &quot;System&quot;
Raw Type: Primitive(Bool)
Storage Item name &quot;UpgradedToU32RefCount&quot;
Storage Item type StorageValue
Code:
fn submit_to_UpgradedToU32RefCount(testinput)
random input is: &quot;let testinput: bool = true&quot;
-------------------
Pallet: &quot;System&quot;
Raw Type: Primitive(Bool)
Storage Item name &quot;UpgradedToTripleRefCount&quot;
Storage Item type StorageValue
Code:
fn submit_to_UpgradedToTripleRefCount(testinput)
random input is: &quot;let testinput: bool = false&quot;
-------------------
Pallet: &quot;System&quot;
Raw Type: Variant(TypeDefVariant { variants: [Variant { name: &quot;ApplyExtrinsic&quot;, fields: [Field { name: None, ty: UntrackedSymbol { id: 4, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;u32&quot;), docs: [] }], index: 0, docs: [] }, Variant { name: &quot;Finalization&quot;, fields: [], index: 1, docs: [] }, Variant { name: &quot;Initialization&quot;, fields: [], index: 2, docs: [] }] })
Storage Item name &quot;ExecutionPhase&quot;
Storage Item type StorageValue
Code:
Output could be any of the following:
&quot;ApplyExtrinsic&quot;
&quot;Finalization&quot;
&quot;Initialization&quot;
random input is: &quot;let Query_chain_state = System.ExecutionPhase(); // query the StorageValue &quot;
-------------------
Pallet: &quot;Timestamp&quot;
Raw Type: Primitive(U64)
Storage Item name &quot;Now&quot;
Storage Item type StorageValue
Code:
fn submit_to_Now(testinput)
random input is: &quot;let testinput: u64 = 6356334091091031003u64&quot;
-------------------
Pallet: &quot;Timestamp&quot;
Raw Type: Primitive(Bool)
Storage Item name &quot;DidUpdate&quot;
Storage Item type StorageValue
Code:
fn submit_to_DidUpdate(testinput)
random input is: &quot;let testinput: bool = false&quot;
-------------------
Pallet: &quot;Aura&quot;
Raw Type: Composite(TypeDefComposite { fields: [Field { name: None, ty: UntrackedSymbol { id: 72, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;Vec&lt;T&gt;&quot;), docs: [] }] })
Storage Item name &quot;Authorities&quot;
Storage Item type StorageValue
Code:
random input is: &quot;let output: Vec&lt;T&gt; = query_storage_map(Authorities)&quot;
-------------------
Pallet: &quot;Aura&quot;
Raw Type: Composite(TypeDefComposite { fields: [Field { name: None, ty: UntrackedSymbol { id: 10, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;u64&quot;), docs: [] }] })
Storage Item name &quot;CurrentSlot&quot;
Storage Item type StorageValue
Code:
random input is: &quot;let output: u64 = query_storage_map(CurrentSlot)&quot;
-------------------
Pallet: &quot;Grandpa&quot;
Raw Type: Variant(TypeDefVariant { variants: [Variant { name: &quot;Live&quot;, fields: [], index: 0, docs: [] }, Variant { name: &quot;PendingPause&quot;, fields: [Field { name: Some(&quot;scheduled_at&quot;), ty: UntrackedSymbol { id: 4, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;N&quot;), docs: [] }, Field { name: Some(&quot;delay&quot;), ty: UntrackedSymbol { id: 4, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;N&quot;), docs: [] }], index: 1, docs: [] }, Variant { name: &quot;Paused&quot;, fields: [], index: 2, docs: [] }, Variant { name: &quot;PendingResume&quot;, fields: [Field { name: Some(&quot;scheduled_at&quot;), ty: UntrackedSymbol { id: 4, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;N&quot;), docs: [] }, Field { name: Some(&quot;delay&quot;), ty: UntrackedSymbol { id: 4, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;N&quot;), docs: [] }], index: 3, docs: [] }] })
Storage Item name &quot;State&quot;
Storage Item type StorageValue
Code:
Output could be any of the following:
&quot;Live&quot;
&quot;PendingPause&quot;
&quot;Paused&quot;
&quot;PendingResume&quot;
random input is: &quot;let Query_chain_state = Grandpa.State(); // query the StorageValue &quot;
-------------------
Pallet: &quot;Grandpa&quot;
Raw Type: Composite(TypeDefComposite { fields: [Field { name: Some(&quot;scheduled_at&quot;), ty: UntrackedSymbol { id: 4, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;N&quot;), docs: [] }, Field { name: Some(&quot;delay&quot;), ty: UntrackedSymbol { id: 4, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;N&quot;), docs: [] }, Field { name: Some(&quot;next_authorities&quot;), ty: UntrackedSymbol { id: 76, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;BoundedAuthorityList&lt;Limit&gt;&quot;), docs: [] }, Field { name: Some(&quot;forced&quot;), ty: UntrackedSymbol { id: 77, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;Option&lt;N&gt;&quot;), docs: [] }] })
Storage Item name &quot;PendingChange&quot;
Storage Item type StorageValue
Code:
random input is: &quot;let output: N = query_storage_map(PendingChange)&quot;
-------------------
Pallet: &quot;Grandpa&quot;
Raw Type: Primitive(U32)
Storage Item name &quot;NextForced&quot;
Storage Item type StorageValue
Code:
fn submit_to_NextForced(testinput)
random input is: &quot;let testinput: u32 = 3348882527u32&quot;
-------------------
Pallet: &quot;Grandpa&quot;
Raw Type: Tuple(TypeDefTuple { fields: [UntrackedSymbol { id: 4, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, UntrackedSymbol { id: 4, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }] })
Storage Item name &quot;Stalled&quot;
Storage Item type StorageValue
Code:
Type definition of tuple output: 
tuple (
Primitive(U32)
Primitive(U32)
) // end of tuple
random input is: &quot;let Query_chain_state = Grandpa.Stalled(); // query the StorageValue, output is a tuple of &quot;
-------------------
Pallet: &quot;Grandpa&quot;
Raw Type: Primitive(U64)
Storage Item name &quot;CurrentSetId&quot;
Storage Item type StorageValue
Code:
fn submit_to_CurrentSetId(testinput)
random input is: &quot;let testinput: u64 = 10791354850851657412u64&quot;
-------------------
Pallet: &quot;Grandpa&quot;
Raw Type: Primitive(U32)
Storage Item name &quot;SetIdSession&quot;
Storage Item type StorageMap
Code:
fn submit_to_SetIdSession(testinput)
random input is: &quot;let testinput: u32 = 1303990955u32&quot;
-------------------
Pallet: &quot;Balances&quot;
Raw Type: Primitive(U128)
Storage Item name &quot;TotalIssuance&quot;
Storage Item type StorageValue
Code:
fn submit_to_TotalIssuance(testinput)
random input is: &quot;let testinput: u128 = 241209649674657693693679353451022133585u128&quot;
-------------------
Pallet: &quot;Balances&quot;
Raw Type: Primitive(U128)
Storage Item name &quot;InactiveIssuance&quot;
Storage Item type StorageValue
Code:
fn submit_to_InactiveIssuance(testinput)
random input is: &quot;let testinput: u128 = 70649824094909238760224179934204586030u128&quot;
-------------------
Pallet: &quot;Balances&quot;
Raw Type: Composite(TypeDefComposite { fields: [Field { name: Some(&quot;free&quot;), ty: UntrackedSymbol { id: 6, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;Balance&quot;), docs: [] }, Field { name: Some(&quot;reserved&quot;), ty: UntrackedSymbol { id: 6, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;Balance&quot;), docs: [] }, Field { name: Some(&quot;misc_frozen&quot;), ty: UntrackedSymbol { id: 6, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;Balance&quot;), docs: [] }, Field { name: Some(&quot;fee_frozen&quot;), ty: UntrackedSymbol { id: 6, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;Balance&quot;), docs: [] }] })
Storage Item name &quot;Account&quot;
Storage Item type StorageMap
Code:
random input is: &quot;let output: Balance = query_storage_map(Account)&quot;
-------------------
Pallet: &quot;Balances&quot;
Raw Type: Composite(TypeDefComposite { fields: [Field { name: None, ty: UntrackedSymbol { id: 95, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;Vec&lt;T&gt;&quot;), docs: [] }] })
Storage Item name &quot;Locks&quot;
Storage Item type StorageMap
Code:
random input is: &quot;let output: Vec&lt;T&gt; = query_storage_map(Locks)&quot;
-------------------
Pallet: &quot;Balances&quot;
Raw Type: Composite(TypeDefComposite { fields: [Field { name: None, ty: UntrackedSymbol { id: 98, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;Vec&lt;T&gt;&quot;), docs: [] }] })
Storage Item name &quot;Reserves&quot;
Storage Item type StorageMap
Code:
random input is: &quot;let output: Vec&lt;T&gt; = query_storage_map(Reserves)&quot;
-------------------
Pallet: &quot;TransactionPayment&quot;
Raw Type: Composite(TypeDefComposite { fields: [Field { name: None, ty: UntrackedSymbol { id: 6, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;u128&quot;), docs: [] }] })
Storage Item name &quot;NextFeeMultiplier&quot;
Storage Item type StorageValue
Code:
random input is: &quot;let output: u128 = query_storage_map(NextFeeMultiplier)&quot;
-------------------
Pallet: &quot;TransactionPayment&quot;
Raw Type: Variant(TypeDefVariant { variants: [Variant { name: &quot;V1Ancient&quot;, fields: [], index: 0, docs: [] }, Variant { name: &quot;V2&quot;, fields: [], index: 1, docs: [] }] })
Storage Item name &quot;StorageVersion&quot;
Storage Item type StorageValue
Code:
Output could be any of the following:
&quot;V1Ancient&quot;
&quot;V2&quot;
random input is: &quot;let Query_chain_state = TransactionPayment.StorageVersion(); // query the StorageValue &quot;
-------------------
Pallet: &quot;Sudo&quot;
Raw Type: Composite(TypeDefComposite { fields: [Field { name: None, ty: UntrackedSymbol { id: 1, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;[u8; 32]&quot;), docs: [] }] })
Storage Item name &quot;Key&quot;
Storage Item type StorageValue
Code:
random input is: &quot;let output: [u8; 32] = query_storage_map(Key)&quot;
-------------------
Pallet: &quot;TemplateModule&quot;
Raw Type: Primitive(U32)
Storage Item name &quot;Something&quot;
Storage Item type StorageValue
Code:
fn submit_to_Something(testinput)
random input is: &quot;let testinput: u32 = 2166200555u32&quot;
-------------------
Pallet: &quot;TemplateModule&quot;
Raw Type: Primitive(U64)
Storage Item name &quot;Something2&quot;
Storage Item type StorageValue
Code:
fn submit_to_Something2(testinput)
random input is: &quot;let testinput: u64 = 13381854620199913039u64&quot;
-------------------
Pallet: &quot;TemplateModule&quot;
Raw Type: Primitive(U128)
Storage Item name &quot;Something6&quot;
Storage Item type StorageValue
Code:
fn submit_to_Something6(testinput)
random input is: &quot;let testinput: u128 = 175114842145234008150363523808777702541u128&quot;
-------------------
Pallet: &quot;TemplateModule&quot;
Raw Type: Composite(TypeDefComposite { fields: [Field { name: None, ty: UntrackedSymbol { id: 1, marker: PhantomData&lt;fn() -&gt; core::any::TypeId&gt; }, type_name: Some(&quot;[u8; 32]&quot;), docs: [] }] })
Storage Item name &quot;SomeMapfirst&quot;
Storage Item type StorageMap
Code:
random input is: &quot;let output: [u8; 32] = query_storage_map(SomeMapfirst)&quot;
-------------------
Pallet: &quot;TemplateModule&quot;
Raw Type: Primitive(U32)
Storage Item name &quot;NumberResultQuery&quot;
Storage Item type StorageValue
Code:
fn submit_to_NumberResultQuery(testinput)
random input is: &quot;let testinput: u32 = 308558816u32&quot;
-------------------
Pallet: &quot;TemplateModule&quot;
Raw Type: Primitive(U64)
Storage Item name &quot;SomeMaptwos&quot;
Storage Item type StorageValue
Code:
fn submit_to_SomeMaptwos(testinput)
random input is: &quot;let testinput: u64 = 11545124980994761057u64&quot;
-------------------
Pallet: &quot;TemplateModule&quot;
Raw Type: Primitive(U64)
Storage Item name &quot;SomeMaptwo&quot;
Storage Item type StorageMap
Code:
fn submit_to_SomeMaptwo(testinput)
random input is: &quot;let testinput: u64 = 6774784951135778396u64&quot;
-------------------
Pallet: &quot;TemplateModule&quot;
Raw Type: Primitive(U32)
Storage Item name &quot;SomeMapthree&quot;
Storage Item type StorageMap
Code:
fn submit_to_SomeMapthree(testinput)
random input is: &quot;let testinput: u32 = 659067354u32&quot;
-------------------


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libuptest-auto-test"><a class="header" href="#libuptest-auto-test">Libuptest auto-test</a></h1>
<p>Libuptest supports automatically generating types for the storage entry types:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
u8</li>
<li><input disabled="" type="checkbox" checked=""/>
u32 </li>
<li><input disabled="" type="checkbox" checked=""/>
u64</li>
<li><input disabled="" type="checkbox" checked=""/>
u128</li>
<li><input disabled="" type="checkbox" checked=""/>
Boolean</li>
<li><input disabled="" type="checkbox" checked=""/>
Balances(to a certain degree)</li>
<li><input disabled="" type="checkbox" checked=""/>
TypeDef::Composite types</li>
<li><input disabled="" type="checkbox" checked=""/>
Tuples</li>
</ul>
<h4 id="interact-with-inputhelper"><a class="header" href="#interact-with-inputhelper">Interact with InputHelper</a></h4>
<p>The auto-test module use <code>InputHelper</code> to generate random input for the user.</p>
<h2 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml:</a></h2>
<p>Enable the <code>auto-test</code> feature flag.</p>
<pre><code class="language-toml">libuptest = { git = &quot;https://github.com/uptest-sc/uptest&quot;, version = &quot;0.1.3&quot;, features = [&quot;auto-test&quot;]}
</code></pre>
<h2 id="libuptest-1"><a class="header" href="#libuptest-1">Libuptest:</a></h2>
<p>Code example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use libuptest::error::Error;
use libuptest::jsonrpseeclient::JsonrpseeClient;
use libuptest::test_generation::autogen::{generate_auto_test, generate_test_std, AutoTestSummary, AutoTests};


/// generate a summary(AutoTestSummary) of suggested generated ways to query each storage item
async fn generate_tests(client: JsonrpseeClient) -&gt; Result&lt;AutoTests, Error&gt; {
	// parse each storage entry and recommend a way to query it, similar to cli auto-test
	let auto_tests: Vec&lt;AutoTestSummary&gt; = generate_auto_test(client).await?:
	Ok(AutoTests)
}

/// cli version, this outputs the same data but directly to stdout with a old fashion print
async fn generate_cli_output(client: JsonrpseeClient) -&gt; Result&lt;(), Error&gt; {
	// print info about quering each storage entry
	let _out = generate_test_std(client).await?;
	Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="resources"><a class="header" href="#resources">Resources:</a></h3>
<p><a href="https://github.com/uptest-sc/uptest/blob/main/cli/src/helper.rs#L31">cli auto-test</a><br />
<a href="https://github.com/uptest-sc/uptest/tree/main/libuptest/src/test_generation">auto-test module code</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
